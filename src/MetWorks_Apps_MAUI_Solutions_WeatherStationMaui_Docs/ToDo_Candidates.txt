ToDo Candidates (MetWorks-WeatherStationMAUI)
=====================================

1) Make custom DI / initialization less synchronous
- Goal: Let MAUI start without blocking on full DDI registry initialization.
- Approach candidates:
  - Two-phase startup: Create services synchronously; initialize asynchronously after UI is up.
  - Per-service readiness gates (Task-based readiness) instead of global "all initialized" gate.
  - AsyncLazy / single-flight initialization for named instances.
  - Proxy/buffering components for optional dependencies (network/DB) to avoid startup failures.
  - Defer expensive I/O (Postgres connect/schema init) or run in degraded mode until ready.

2) Reduce sync-over-async in MAUI startup
- Goal: Minimize or eliminate usages of .GetAwaiter().GetResult() in CreateMauiApp.
- Approach candidates:
  - Move initialization to App/AppShell startup path and present a loading UI.
  - Ensure library/service initialization paths use ConfigureAwait(false) when sync blocking is unavoidable.

3) Standardize async guidance across services
- Goal: Avoid deadlocks and brittle startup by consistent patterns.
- Candidates:
  - Use ConfigureAwait(false) in non-UI / library code paths.
  - Ensure every async I/O call has timeout + cancellation token passed through.
  - Keep async init idempotent with Interlocked guards.

4) MAUI constructor DI for Pages/ViewModels
- Goal: Stop new'ing ViewModels directly; let MAUI DI create Pages and ViewModels.
- Candidates:
  - Register Page/ViewModel pairs with desired lifetimes.
  - Adopt navigation/route strategy that resolves pages from IServiceProvider.

5) Postgres init hardening
- Goal: Postgres is optional at startup; app should run degraded and later recover.
- Candidates:
  - Keep connect/query timeouts explicit.
  - Keep schema init tolerant.
  - Improve observability (timing + where it blocks).

6) DDI-generated code and tokens
- Goal: Generated code should pass CancellationToken (not CTS) and support property definitions on class declarations.
- Reference: MetWorks-DeclarativeDI repo modernization items.

7) Automated testing
- Goal: Add automated tests and CI to validate core behaviors across ViewModels, services, initializers, and persistence.
- Approach candidates:
  - Add unit and integration tests using the test framework already in the repo (prefer xUnit if present). Create a dedicated test project `WeatherStation.Tests` that mirrors critical surface area (ViewModels, Services, persistence adapters).
  - Add CI pipeline that runs tests on push/PR and reports results; include a job for integration tests that can run in an emulated or in-memory mode.
  - Prefer integration tests that exercise the real event-driven path (`IEventRelayBasic`) rather than adding test-only interfaces.

8) Live settings publish/subscribe
- Goal: Complete runtime support so setting changes are published to subscribers and applied live (example: Celsius/Fahrenheit toggle updates UI and conversions instantly).
- Approach candidates:
  - Use the existing `IEventRelayBasic` as the canonical messaging surface; ensure setting change messages carry typed payloads and a source/actor id.
  - Ensure subscribers apply updates immediately, accept a `CancellationToken`, and are idempotent. Verify handlers use ConfigureAwait(false) where appropriate.
  - Add unit/integration tests that assert subscribers receive and apply changes and that UI-bound ViewModels update correctly.

9) Local SQLite caching and remote flush
- Goal: Cache sensor readings to a local SQLite store and flush them to a remote DB (Postgres) when connectivity is available, without blocking the UI.
- Approach candidates:
  - Implement a local SQLite persistence adapter with durable writes and consumption semantics (FIFO or timestamp-ordered). Keep schema simple and versioned.
  - Add a background flusher service (prefer `ServiceBase` patterns) that reads batches, writes to remote DB with timeouts and batching, and retries with exponential backoff on transient failures.
  - Make remote writes resilient: non-blocking, bounded concurrency, and observability (metrics/logging). Add tests that simulate offline mode and verify no data-loss when flushing succeeds.

10) Type-aware settings editor UI
- Goal: Allow changing settings via UI using Setting metadata so editors validate and serialize values by type (numbers, enums, booleans, strings) and enforce ranges/choices.
- Approach candidates:
  - Expose a `SettingsManager` that stores setting metadata (type, range, enum values, display name, description) and emits typed change events via `IEventRelayBasic`.
  - Build a small type-driven editor UI that renders the appropriate control for each setting and performs client-side validation before publishing changes.
  - Add tests for the SettingsManager and ViewModels that validate metadata-driven editing, validation errors, and round-trip serialization of values.

11) Per-installation instance identifier (GUID)
- Goal: Create and persist a stable GUID the first time the app runs to uniquely identify this installation when writing shared persistence (Postgres, remote telemetry) so entries from different installations can be differentiated.
- Approach candidates:
  - On first run generate a `Guid` and persist it in a platform-appropriate local store (Preferences, secure storage, or a local file in app data). Expose via a `IInstanceIdentifier` or `InstanceIdentifier` singleton.
  - Ensure reads are synchronous-safe during startup (provide a lightweight cached accessor) and generation is idempotent (use file/atomic write or Preferences.TryGet/Set semantics).
  - Surface the instance id through telemetry/logging and include when writing DB entries. Allow migration/rotation via a dev-only command or settings UI.
  - Add unit/integration tests that verify generation-on-first-run, persistence across restarts, and inclusion in outgoing persistence operations.

  Implementation notes (current):
  - Reuse the existing settings mechanism. Added a non-editable definition at `/services/instance/installationId` in the resource `data.settings.yaml`.
  - Extend `ISettingProvider` with `SaveValueOverride(string path, string value)` and implement it in `SettingProvider` to persist overrides to a YAML file under `%LocalAppData%/MetWorks-WeatherStationMAUI/data.settings.yaml` (atomic temp-file write + move).
  - Add an `InstanceIdentifier` service that reads the setting value (in-memory provider values or definition) and, if missing, generates a new GUID, persists it via `SaveValueOverride`, and caches it for synchronous access.
  - Register `InstanceIdentifier` into MAUI DI after the DDI-generated registry has registered its singletons so other components can resolve it. Prefer resolving via DI and call `GetOrCreateInstallationId()`.
  - The persistence approach keeps settings usage consistent and avoids adding a separate storage subsystem. Writes are atomic and failures fall back to a transient GUID while logging warnings.

  Next work / tests:
  - Add unit tests for the new provider save logic and `InstanceIdentifier` behavior (generation, persistence, caching, and restart semantics).
  - Expose a helper command to rotate or reset the installation id (dev-only) so operators can migrate an installation id when required.
  - Documentation: update docs to reference `LookupDictionaries.<Group>GroupSettingsDefinition.BuildSettingPath(name)` for reading specific settings and `BuildGroupPath()` for registering prefix handlers with `IEventRelayPath` rather than using hard-coded `/services/...` string literals.
  - Docs sweep: replace textual references in repository docs that hard-code `/services/...` with canonical API examples and guidance.
  - Prepare PR summary and changelog entry describing these changes (settings override persistence, InstanceIdentifier service, tests, and docs updates).
