ToDo Candidates (MetWorks-WeatherStationMAUI)
=====================================

1) Make custom DI / initialization less synchronous
- Goal: Let MAUI start without blocking on full DDI registry initialization.
- Approach candidates:
  - Two-phase startup: Create services synchronously; initialize asynchronously after UI is up.
  - Per-service readiness gates (Task-based readiness) instead of global "all initialized" gate.
  - AsyncLazy / single-flight initialization for named instances.
  - Proxy/buffering components for optional dependencies (network/DB) to avoid startup failures.
  - Defer expensive I/O (Postgres connect/schema init) or run in degraded mode until ready.

2) Reduce sync-over-async in MAUI startup
- Goal: Minimize or eliminate usages of .GetAwaiter().GetResult() in CreateMauiApp.
- Approach candidates:
  - Move initialization to App/AppShell startup path and present a loading UI.
  - Ensure library/service initialization paths use ConfigureAwait(false) when sync blocking is unavoidable.

3) Standardize async guidance across services
- Goal: Avoid deadlocks and brittle startup by consistent patterns.
- Candidates:
  - Use ConfigureAwait(false) in non-UI / library code paths.
  - Ensure every async I/O call has timeout + cancellation token passed through.
  - Keep async init idempotent with Interlocked guards.

4) MAUI constructor DI for Pages/ViewModels
- Goal: Stop new'ing ViewModels directly; let MAUI DI create Pages and ViewModels.
- Candidates:
  - Register Page/ViewModel pairs with desired lifetimes.
  - Adopt navigation/route strategy that resolves pages from IServiceProvider.

5) Postgres init hardening
- Goal: Postgres is optional at startup; app should run degraded and later recover.
- Candidates:
  - Keep connect/query timeouts explicit.
  - Keep schema init tolerant.
  - Improve observability (timing + where it blocks).

6) DDI-generated code and tokens
- Goal: Generated code should pass CancellationToken (not CTS) and support property definitions on class declarations.
- Reference: MetWorks-DeclarativeDI repo modernization items.

7) Automated testing
- Goal: Add automated tests and CI to validate core behaviors across ViewModels, services, initializers, and persistence.
- Approach candidates:
  - Add unit and integration tests using the test framework already in the repo (prefer xUnit if present). Create a dedicated test project `WeatherStation.Tests` that mirrors critical surface area (ViewModels, Services, persistence adapters).
  - Add CI pipeline that runs tests on push/PR and reports results; include a job for integration tests that can run in an emulated or in-memory mode.
  - Prefer integration tests that exercise the real event-driven path (`IEventRelayBasic`) rather than adding test-only interfaces.

8) Live settings publish/subscribe
- Goal: Complete runtime support so setting changes are published to subscribers and applied live (example: Celsius/Fahrenheit toggle updates UI and conversions instantly).
- Approach candidates:
  - Use the existing `IEventRelayBasic` as the canonical messaging surface; ensure setting change messages carry typed payloads and a source/actor id.
  - Ensure subscribers apply updates immediately, accept a `CancellationToken`, and are idempotent. Verify handlers use ConfigureAwait(false) where appropriate.
  - Add unit/integration tests that assert subscribers receive and apply changes and that UI-bound ViewModels update correctly.

9) Local SQLite caching and remote flush
- Goal: Cache sensor readings to a local SQLite store and flush them to a remote DB (Postgres) when connectivity is available, without blocking the UI.
- Approach candidates:
  - Implement a local SQLite persistence adapter with durable writes and consumption semantics (FIFO or timestamp-ordered). Keep schema simple and versioned.
  - Add a background flusher service (prefer `ServiceBase` patterns) that reads batches, writes to remote DB with timeouts and batching, and retries with exponential backoff on transient failures.
  - Make remote writes resilient: non-blocking, bounded concurrency, and observability (metrics/logging). Add tests that simulate offline mode and verify no data-loss when flushing succeeds.

10) Type-aware settings editor UI
- Goal: Allow changing settings via UI using Setting metadata so editors validate and serialize values by type (numbers, enums, booleans, strings) and enforce ranges/choices.
- Approach candidates:
  - Expose a `SettingsManager` that stores setting metadata (type, range, enum values, display name, description) and emits typed change events via `IEventRelayBasic`.
  - Build a small type-driven editor UI that renders the appropriate control for each setting and performs client-side validation before publishing changes.
  - Add tests for the SettingsManager and ViewModels that validate metadata-driven editing, validation errors, and round-trip serialization of values.

11) Per-installation instance identifier (GUID)
- Goal: Create and persist a stable GUID the first time the app runs to uniquely identify this installation when writing shared persistence (Postgres, remote telemetry) so entries from different installations can be differentiated.
- Approach candidates:
  - On first run generate a `Guid` and persist it in a platform-appropriate local store (Preferences, secure storage, or a local file in app data). Expose via a `IInstanceIdentifier` or `InstanceIdentifier` singleton.
  - Ensure reads are synchronous-safe during startup (provide a lightweight cached accessor) and generation is idempotent (use file/atomic write or Preferences.TryGet/Set semantics).
  - Surface the instance id through telemetry/logging and include when writing DB entries. Allow migration/rotation via a dev-only command or settings UI.
  - Add unit/integration tests that verify generation-on-first-run, persistence across restarts, and inclusion in outgoing persistence operations.

  Implementation notes (current):
  - Reuse the existing settings mechanism. Added a non-editable definition at `/services/instance/installationId` in the resource `data.settings.yaml`.
  - Extend `ISettingProvider` with `SaveValueOverride(string path, string value)` and implement it in `SettingProvider` to persist overrides to a YAML file under `%LocalAppData%/MetWorks-WeatherStationMAUI/data.settings.yaml` (atomic temp-file write + move).
  - Add an `InstanceIdentifier` service that reads the setting value (in-memory provider values or definition) and, if missing, generates a new GUID, persists it via `SaveValueOverride`, and caches it for synchronous access.
  - Register `InstanceIdentifier` into MAUI DI after the DDI-generated registry has registered its singletons so other components can resolve it. Prefer resolving via DI and call `GetOrCreateInstallationId()`.
  - The persistence approach keeps settings usage consistent and avoids adding a separate storage subsystem. Writes are atomic and failures fall back to a transient GUID while logging warnings.

  Next work / tests:
  - Add unit tests for the new provider save logic and `InstanceIdentifier` behavior (generation, persistence, caching, and restart semantics).
  - Expose a helper command to rotate or reset the installation id (dev-only) so operators can migrate an installation id when required.
  - Documentation: update docs to reference `LookupDictionaries.<Group>GroupSettingsDefinition.BuildSettingPath(name)` for reading specific settings and `BuildGroupPath()` for registering prefix handlers with `IEventRelayPath` rather than using hard-coded `/services/...` string literals.
  - Docs sweep: replace textual references in repository docs that hard-code `/services/...` with canonical API examples and guidance.
  - Prepare PR summary and changelog entry describing these changes (settings override persistence, InstanceIdentifier service, tests, and docs updates).
Applied work and remaining suggested changes
==========================================

Summary of notable changes already applied in the workspace (during recent session):
- Moved startup splash into `AppShell` and implemented Shell-based navigation so `Shell.Current` is available and the splash is shown exactly once.
- Implemented create-vs-init startup: `StartupInitializer.CreateRegistryAndRegisterServices(IServiceCollection)` registers DDI-created instances into MAUI DI before `builder.Build()`; `StartupInitializer.InitializeAsync()` runs the long-running init in background and emits events (`StatusChanged`, `Initialized`, `InitializationFailed`).
- Added ConfigureAwait(false) fixes in background/service files (UDP listener, Postgres ingestor, logger worker) to avoid capturing UI context in services.
- Added a lightweight splash/progress page `InitializationSplashPage` and wiring to startup events.

Note on third-party code (RedStar)
---------------------------------
- This project uses `RedStar.Amounts` for unit definitions and conversions. We intentionally avoid
  modifying `RedStar.Amounts` or `RedStar.Amount.StandardUnits` in this repository so upstream
  updates remain simple. For diagnostics or linker-preserve work, prefer wrapper/adapter code
  or documentation notes rather than editing RedStar sources directly. Credit to the RedStar
  project for providing the unit definitions and conversion helpers used here.

Remaining suggested tasks (recommended, not yet implemented)
-----------------------------------------------------
These are suggestions from previous diagnostics and code review that were not implemented automatically. They're ordered by impact/priority with short rationale and a recommended owner/approach.

A. Diagnostic & linker-hardening for Android (high)
- Add targeted diagnostics when reflection-based loading fails in the `RedStar.Amounts` assembly: catch `ReflectionTypeLoadException` in `UnitManager.RegisterUnits(Assembly)` and log `LoaderExceptions` with full type names and messages so logcat shows exactly what was trimmed.
- Add a conservative Android linker preservation rule (linker.xml) or `[Preserve]` attributes for types referenced only via reflection (unit definition classes, conversion classes, parsing helpers). Prefer a small linker XML preserving the specific `RedStar.Amounts` namespace/types.
- Disable the linker for Debug temporarily (csproj `<AndroidLinkMode>None</AndroidLinkMode>`) to confirm the linker is the root cause.

B. Per-service readiness (medium)
- Add a standard readiness pattern to long-running services:
  - internal `TaskCompletionSource<bool> _readyTcs` set to true when service is ready
  - public `Task Ready => _readyTcs.Task` and `bool IsReady` property
  - Consumers may `await service.Ready` or check `IsReady` before performing init-dependent calls.
- Implement the pattern for at least one critical service (e.g., `TempestPacketTransformer` or `RawPacketIngestor`) as an example.

C. More granular startup status messages (low/UX)
- Emit more granular `StatusChanged` messages from `StartupInitializer.RegisterServices()` at clear checkpoints: "Creating registry", "Initializing UDP listener", "Starting Postgres listener (degraded)", "Postgres connected", "Registering DDI singletons", etc. This improves splash UX and diagnostics.

D. Route naming and registration cleanup (low)
- Replace dynamic route strings (type names) with explicit route constants to avoid string typos. Centralize route constants in a static `Routes` class and register them in `AppShell.RegisterRoutes()`.

E. Audit & refactor direct `Registry` usages (medium)
- Scan repository for direct usages of `StartupInitializer.Registry` and replace with DI where sensible. Where direct registry access is necessary, add guarded checks (e.g., `if (StartupInitializer.IsInitialized)`) or use lazy resolution.

F. Move route registration into XAML (optional)
- For a cleaner separation, declare `ShellContent` and routes in `AppShell.xaml` and use code-behind only to swap the initial content after init. This is mostly cosmetic but yields clearer markup-driven navigation.

G. Add targeted unit/integration tests (medium)
- Add tests for: `InstanceIdentifier` generation/persistence, `UnitManager` registration behavior (including fallback UnitResolve handler), and a small integration test exercising the `IEventRelayBasic` flow for a ViewModel.

H. Example: add diagnostic logging around `UnitManager.RegisterUnits` (quick task)
- Implement a small try/catch around assembly scanning to capture loader exceptions and log them to the resilient logger file so Android logcat contains the exact failure. This is the recommended first step to confirm linker trimming is the real issue.

How to proceed (recommended next actions)
1. Implement (H) diagnostic logging in `RedStar.Amounts.UnitManager.RegisterUnits` and repro on Android to capture `LoaderExceptions` in logcat.
2. If diagnostics point to linker trimming, add a small linker XML preserving the `RedStar.Amounts` namespace and re-run. Only widen preservation if necessary.
3. Implement per-service `Ready` Task on one critical service and update a sample page to await it before accessing initialization-dependent APIs.
4. Add route constants and centralize registration as a follow-up refactor.

If you want I can implement (H) now (small code changes and quick build) and then prepare the conservative linker XML. Tell me which to do next.

